# 用ortools和灰狼算法求解JSP和FJSP问题。


在程序开始时，将输入数据的第一行第三元素，做一个判断，如果工序的平均机器数量为1，则进入 MinimalJobshopSat()函数，用ortools求解JSP问题。
ortools作为完备算法，求解JSP问题非常强力，针对FT和LA级别的数据集，均能在短时间内求出最优解，这是常规的元启发式算法难以企及的。  

如果是FJSP问题，则用灰狼算法解决问题，本次选择灰狼算法的原因是，查询近年来核心期刊文献，灰狼算法在求解调度问题中，逐渐占据优势，多数的FJSP问题的发刊文章，
都是来自灰狼算法。  



# 灰狼算法的实现逻辑
1）社会等级分层
GWO的优化过程主要有每代种群中的最好三匹狼（具体构建时表示为三个最好的解）来指导完成。

2）包围猎物
灰狼捜索猎物时会逐渐地接近猎物并包围它，该行为的数学模型如下：
![image](https://user-images.githubusercontent.com/71360947/185347334-34fad858-a57d-4e6d-9aec-e24565851e91.png)


3）狩猎行为的数学模型在这里插入图片描述
![image](https://user-images.githubusercontent.com/71360947/185347438-be5620e7-ddfa-438a-83aa-a58599957b08.png)

放上链接：https://blog.csdn.net/welcome_yu/article/details/112095902





<p style="margin:0;"># 代码及注释</p><p style="margin:0;"><br /></p><p style="margin:0;">from __future__ import print_function&nbsp;&nbsp;</p><p style="margin:0;">import time&nbsp;&nbsp;</p><p style="margin:0;">import chardet</p><p style="margin:0;">import datetime</p><p style="margin:0;">import collections</p><p style="margin:0;">Import Python wrapper for or-tools CP-SAT solver.</p><p style="margin:0;">from ortools.sat.python import cp_model</p><p style="margin:0;">import numpy as np</p><p style="margin:0;">import random</p><p style="margin:0;">import sys</p><p style="margin:0;">import warnings</p><p style="margin:0;">warnings.filterwarnings("ignore")</p><p style="margin:0;">dt = datetime.datetime</p><p style="margin:0;">time_delta = datetime.timedelta</p><p style="margin:0;"><br /></p><p style="margin:0;">## 根据函数输入最优结果，进行排产操作。</p><p style="margin:0;">def final_caculate(job, machine, machine_time, machine_num, job_num):</p><p style="margin:0;">&nbsp; &nbsp; jobtime = np.zeros((1, job_num))</p><p style="margin:0;">&nbsp; &nbsp; tmm = np.zeros((1, machine_num))</p><p style="margin:0;">&nbsp; &nbsp; tmmw = np.zeros((1, machine_num))</p><p style="margin:0;">&nbsp; &nbsp; job=list(job[0])</p><p style="margin:0;">&nbsp; &nbsp; for i in range(len(job)):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; job[i]=int(job[i])</p><p style="margin:0;">&nbsp; &nbsp; startime = 0</p><p style="margin:0;">&nbsp; &nbsp; list_Machine, list_Starttime, list_W = [], [], []</p><p style="margin:0;">&nbsp; &nbsp; for i in range(len(job)):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; svg, sig = int(job[i]), int(machine[0, i]) - 1</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; if (jobtime[0, svg] &gt; 0):&nbsp; # 第svg个机器的启动运行时间</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startime = max(jobtime[0, svg], tmm[0, sig])</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmm[0, sig] = startime + machine_time[0, i]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jobtime[0, svg] = startime + machine_time[0, i]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; if (jobtime[0, svg] == 0):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startime = tmm[0, sig]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmm[0, sig] = startime + machine_time[0, i]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jobtime[0, svg] = startime + machine_time[0, i]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; tmmw[0, sig] += machine_time[0, i]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; list_Machine.append(machine[0, i])</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; list_Starttime.append(startime)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; list_W.append(machine_time[0, i])</p><p style="margin:0;">&nbsp; &nbsp; job_frequency = [0] * len(job)</p><p style="margin:0;">&nbsp; &nbsp; for i in range(job_num):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; t = 1</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; for j in range(len(job)):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = job[j]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if a == i:</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; job_frequency[j] = t</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t += 1</p><p style="margin:0;">&nbsp; &nbsp; for i in range(len(job)):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; job[i]=str(job[i]+1).rjust(3, '0')</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; job_frequency[i]=str(job_frequency[i]).rjust(2, '0')</p><p style="margin:0;">&nbsp; &nbsp; df_result = []</p><p style="margin:0;">&nbsp; &nbsp; df_temp = []</p><p style="margin:0;">&nbsp; &nbsp; for j in range(len(job)):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; process_tuple = (</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f'S{job[j]}',</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f'S{job[j]}'+f'{job_frequency[j]}',</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int(list_Starttime[j]),</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int(list_Starttime[j] + list_W[j])</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; )</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; df_temp.append(process_tuple)</p><p style="margin:0;">&nbsp; &nbsp; f = open(sys.argv[2], "w")</p><p style="margin:0;">&nbsp; &nbsp; for i in range(machine_num):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; list_c = []</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; for j in range(len(df_temp)):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if i + 1 == list_Machine[j]:</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_c.append(df_temp[j])</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; strs=''</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; for k in range(len(list_c)):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if k==0:</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strs=f'{list_c[k]}'</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else:</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strs = strs + ',' + f'{list_c[k]}'</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; f.write(f'M{i+1}'+':' +strs+'\n')</p><p style="margin:0;">&nbsp; &nbsp; f.close()</p><p style="margin:0;"><br /></p><p style="margin:0;">## 灰狼算法类</p><p style="margin:0;">class GWO_algorithm():</p><p style="margin:0;">&nbsp; &nbsp; def __init__(self, job_num, machine_num, p, iter, popsize_num):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; self.job_num = job_num&nbsp; # 工件数</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; self.machine_num = machine_num&nbsp; # 机器数</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; self.pi = p&nbsp; #交叉概率</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; self.generation = iter&nbsp; # 迭代次数</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; self.popsize = popsize_num&nbsp; # 种群规模</p><p style="margin:0;">&nbsp; &nbsp; #分开输出每个工件的可用机器，可用机器时间，工序可用机器编号</p><p style="margin:0;">&nbsp; &nbsp; def coding(self, tr1):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; sigdex, mac, mact, sdx = [], [], [], []</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; sigal = tr1[0]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; tr1 = tr1[1:len(tr1) + 1]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; index = 0</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; for j in range(sigal):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sig = tr1[index]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sdx.append(sig)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sigdex.append(index)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index = index + 1 + 2 * sig</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; for ij in range(sigal):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; del tr1[sigdex[ij] - ij]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; for ii in range(0, len(tr1) - 1, 2):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mac.append(tr1[ii])</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mact.append(tr1[ii + 1])</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; return mac, mact, sdx</p><p style="margin:0;">&nbsp; &nbsp; #输出原始机器矩阵，机器时间矩阵，机器选择矩阵，放入load_data_GWO中</p><p style="margin:0;">&nbsp; &nbsp; def tcaculate(self, strt):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; widthx = []</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; for i in range(self.job_num):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mac, mact, sdx = self.coding(strt[i])</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; siga = len(mac)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; widthx.append(siga)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; width = max(widthx)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; Tmachine, Tmachinetime = np.zeros((self.job_num, width)), np.zeros((self.job_num, width))</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; tdx = []</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; for i in range(self.job_num):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mac, mact, sdx = self.coding(strt[i])</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tdx.append(sdx)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; siga = len(mac)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Tmachine[i, 0:siga] = mac</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Tmachinetime[i, 0:siga] = mact</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; return Tmachine, Tmachinetime, tdx</p><p style="margin:0;">&nbsp; &nbsp; #从input.txt中读取数据，输出原始机器矩阵，机器时间矩阵，机器选择矩阵，独立工作选择和工作时常。</p><p style="margin:0;">&nbsp; &nbsp; def load_data_GWO(self):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; f = open(sys.argv[1])</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; f1 = f.readlines()</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; c, count = [], 0</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; for line in f1:</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t1 = line.strip('\n')</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (count &gt; 0):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = list(map(int, t1.split()))</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c.append(a)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count += 1</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; strt = c</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; Tmachine, Tmachinetime, tdx = self.tcaculate(strt)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; to, tom, work = 0, [], []</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; for i in range(self.job_num):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to += len(tdx[i])</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tim = []</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for j in range(1, len(tdx[i]) + 1, 1):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tim.append(sum(tdx[i][0:j]))</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; work.append(i)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tom.append(tim)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; Tmachine=Tmachine+1</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; return Tmachine, Tmachinetime, tdx, work, tom</p><p style="margin:0;">&nbsp; &nbsp; # 返回当前迭代种群机器编码和机器时间编码的列表形式。</p><p style="margin:0;">&nbsp; &nbsp; def MA_MAtime_List(self, W1, M1, T1):&nbsp; # 把加工机器编码和加工时间编码转化为对应列表，目的是记录工件的加工时间和加工机器</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; Ma_W1, Tm_W1, WCross = [], [], []</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; for i in range(self.job_num):&nbsp; # 添加工件个数的空列表</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Ma_W1.append([]), Tm_W1.append([]), WCross.append([])</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; for i in range(W1.shape[1]):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; signal1 = int(W1[0, i]) - 1</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Ma_W1[signal1].append(M1[0, i]), Tm_W1[signal1].append(T1[0, i])&nbsp; # 记录每个工件的加工机器</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index = np.random.randint(0, 2, 1)[0]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WCross[signal1].append(index)&nbsp; # 随机生成一个为0或者1的列表，用于后续的机器的均匀交叉</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; return Ma_W1, Tm_W1, WCross</p><p style="margin:0;">&nbsp; &nbsp; #返回单个例子机器编码和机器时间编码的列表形式。</p><p style="margin:0;">&nbsp; &nbsp; def MA_MAtime(self, W1, Ma_W1, Tm_W1):&nbsp; # 列表返回机器及加工时间编码</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; memory1 = np.zeros((1, self.job_num), dtype=np.int)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; m1, t1 = np.zeros((1, W1.shape[1])), np.zeros((1, W1.shape[1]))</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; for i in range(W1.shape[1]):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; signal1 = int(W1[0, i]) - 1</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m1[0, i] = Ma_W1[signal1][memory1[0, signal1]]&nbsp; # 读取对应工序的加工机器</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t1[0, i] = Tm_W1[signal1][memory1[0, signal1]]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memory1[0, signal1] += 1</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; return m1, t1</p><p style="margin:0;">&nbsp; &nbsp; #用于交换工序编码，产生种群多样性。</p><p style="margin:0;">&nbsp; &nbsp; def machine_cross(self, Ma_W1, Tm_W1, Ma_W2, Tm_W2, WCross):&nbsp; # 机器均匀交叉</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; MC1, MC2, TC1, TC2 = [], [], [], []</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; for i in range(self.job_num):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MC1.append([]), MC2.append([]), TC1.append([]), TC2.append([])</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for j in range(len(WCross[i])):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (WCross[i][j] == 0):&nbsp; # 为0时继承另一个父代的加工机器选择</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MC1[i].append(Ma_W1[i][j]), MC2[i].append(Ma_W2[i][j]), TC1[i].append(Tm_W1[i][j]), TC2[i].append(</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Tm_W2[i][j])</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else:&nbsp; # 为1时继承父代的机器选择</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MC2[i].append(Ma_W1[i][j]), MC1[i].append(Ma_W2[i][j]), TC2[i].append(Tm_W1[i][j]), TC1[i].append(</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Tm_W2[i][j])</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; return MC1, TC1, MC2, TC2</p><p style="margin:0;">&nbsp; &nbsp; #用于创造工序编码，机器编码，时间编码，利于后续灰狼算法的运算。</p><p style="margin:0;">&nbsp; &nbsp; def creat_process(self):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; initial_a = np.random.rand(len(self.work))</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; index_work = np.array(initial_a).argsort()</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; job = []</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; for i in range(len(self.work)):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; job.append(self.work[index_work[i]])</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; job = np.array(job).reshape(1, len(self.work))</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; ccount = np.zeros((1, self.job_num), dtype=np.int)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; machine = np.ones((1, job.shape[1]))</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; machine_time = np.ones((1, job.shape[1]))&nbsp; # 初始化矩阵</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; for i in range(job.shape[1]):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oper = int(job[0, i])</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; highs = self.tom[oper][ccount[0, oper]]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lows = self.tom[oper][ccount[0, oper]] - self.tdx[oper][ccount[0, oper]]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n_machine = self.Tmachine[oper, lows:highs]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n_time = self.Tmachinetime[oper, lows:highs]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ccount[0, oper] += 1</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if np.random.rand() &gt; self.pi:&nbsp; # 选取最小加工时间机器</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; machine_time[0, i] = min(n_time)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index = np.argwhere(n_time == machine_time[0, i])</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; machine[0, i] = n_machine[index[0, 0]]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else:&nbsp; # 否则随机挑选机器</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index = np.random.randint(0, len(n_time), 1)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; machine[0, i] = n_machine[index[0]]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; machine_time[0, i] = n_time[index[0]]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; return job, machine, machine_time, initial_a</p><p style="margin:0;">&nbsp; &nbsp; #用于评估当前排列工序的最优解。</p><p style="margin:0;">&nbsp; &nbsp; def caculate(self, job, machine, machine_time):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; jobtime = np.zeros((1, self.job_num))</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; tmm = np.zeros((1, self.machine_num))</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; tmmw = np.zeros((1, self.machine_num))</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; startime = 0</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; list_M, list_S, list_W = [], [], []</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; for i in range(job.shape[1]):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; svg, sig = int(job[0, i]), int(machine[0, i]) - 1</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (jobtime[0, svg] &gt; 0):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startime = max(jobtime[0, svg], tmm[0, sig])</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmm[0, sig] = startime + machine_time[0, i]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jobtime[0, svg] = startime + machine_time[0, i]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (jobtime[0, svg] == 0):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startime = tmm[0, sig]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmm[0, sig] = startime + machine_time[0, i]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jobtime[0, svg] = startime + machine_time[0, i]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmmw[0, sig] += machine_time[0, i]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_M.append(machine[0, i])</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_S.append(startime)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_W.append(machine_time[0, i])</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; tmax = np.argmax(tmm[0]) + 1&nbsp; # 结束最晚的机器</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; C_finish = max(tmm[0])&nbsp; # 最晚完工时间</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; return C_finish, list_M, list_S, list_W, tmax</p><p style="margin:0;">&nbsp; &nbsp; #运行函数，记录灰狼的迭代次数和输出最终最优结果。</p><p style="margin:0;">&nbsp; &nbsp; def gwo_result(self):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; Tmachine, Tmachinetime, tdx, work, tom = self.load_data_GWO()</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; parm_data = [Tmachine, Tmachinetime, tdx, work, tom]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; self.Tmachine, self.Tmachinetime, self.tdx, self.work, self.tom = parm_data[0], parm_data[1], parm_data[2], \</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parm_data[3], parm_data[4]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; answer, result = [], []</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; job_init = np.zeros((self.popsize, len(work)))</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; work_job, work_M, work_T = np.zeros((self.popsize, len(work))), np.zeros((self.popsize, len(work))), np.zeros(</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (self.popsize, len(work)))</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; for gen in range(self.generation):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (gen &lt; 1):&nbsp; # 第一次生成多个可行的工序编码，机器编码，时间编码</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for i in range(self.popsize):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; job, machine, machine_time, initial_a = self.creat_process()</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C_finish, _, _, _, _ = self.caculate(job, machine, machine_time)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; answer.append(C_finish)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; work_job[i], work_M[i], work_T[i] = job[0], machine[0], machine_time[0]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; job_init[i] = initial_a</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print('种群初始的最优解:%.0f' % (min(answer)))</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result.append([gen, min(answer)])&nbsp; # 记录初始解的最小完工时间</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_sort = np.array(answer).argsort()&nbsp; # 返回完工时间从小到大的位置索引</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; work_job1, work_M1, work_T1 = work_job[index_sort], work_M[index_sort], work_T[index_sort]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; answer1 = np.array(answer)[index_sort]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; job_init1 = job_init[index_sort]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Alpha = job_init1[0]&nbsp; # α狼</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Beta = job_init1[1]&nbsp; # β狼</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Delta = job_init1[2]&nbsp; # δ狼</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = 2 * (1 - gen / self.generation)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for i in range(3, self.popsize):&nbsp; # 用最优位置进行工序编码的更新</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; job, machine, machine_time = work_job1[i:i + 1], work_M1[i:i + 1], work_T1[i:i + 1]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Ma_W1, Tm_W1, WCross = self.MA_MAtime_List(job, machine, machine_time)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = job_init1[i</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r1 = random.random()&nbsp; # 灰狼算法解的更新</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r2 = random.random()</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A1 = 2 * a * r1 - a</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C1 = 2 * r2</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; D_alpha = C1 * Alpha - x</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x1 = x - A1 * D_alpha</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r1 = random.random()</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r2 = random.random()</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A2 = 2 * a * r1 - a</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C2 = 2 * r2</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; D_beta = C2 * Beta - x</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x2 = x - A2 * D_beta</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r1 = random.random()</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r2 = random.random()</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A3 = 2 * a * r1 - a</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C3 = 2 * r2</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; D_alpha = C3 * Delta - x</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x3 = x - A3 * D_alpha</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initial_a = (x1 + x2 + x3) / 3&nbsp; # 更新公式</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_work = initial_a.argsort()</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; job_new = []</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for j in range(len(work)):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; job_new.append(work[index_work[j]])</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; job_new = np.array(job_new).reshape(1, len(work))</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; machine_new, time_new = self.MA_MAtime(job_new, Ma_W1, Tm_W1)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C_finish, _, _, _, _ = self.caculate(job_new, machine_new, time_new)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; work_job1[i] = job_new[0]&nbsp; # 更新工序编码</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; job_init1[i] = initial_a</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; work_M1[i], work_T1[i] = machine_new[0], time_new[0]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; answer1[i] = C_finish</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for i in range(0, self.popsize, 2):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; job, machine, machine_time = work_job1[i:i + 1], work_M1[i:i + 1], work_T1[i:i + 1]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Ma_W1, Tm_W1, WCross = self.MA_MAtime_List(job, machine, machine_time)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; job1, machine1, machine_time1 = work_job1[i + 1:i + 2], work_M1[i + 1:i + 2], work_T1[i + 1:i + 2]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Ma_W2, Tm_W2, WCross = self.MA_MAtime_List(job1, machine1, machine_time1)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MC1, TC1, MC2, TC2 = self.machine_cross(Ma_W1, Tm_W1, Ma_W2, Tm_W2, WCross)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; machine_new, time_new = self.MA_MAtime(job, MC1, TC1)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C_finish, _, _, _, _ = self.caculate(job, machine_new, time_new)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (C_finish &lt; answer1[i]):&nbsp; # 如果更新后的完工时间大于原解，更新机器和加工时间编码</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; work_M1[i] = machine_new[0]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; work_T1[i] = time_new[0]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; answer1[i] = C_finish</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; machine_new1, time_new1 = self.MA_MAtime(job1, MC2, TC2)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C_finish, _, _, _, _ = self.caculate(job1, machine_new1, time_new1)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (C_finish &lt; answer1[i + 1]):&nbsp; # 如果更新后的完工时间大于原解，更新机器和加工时间编码</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; work_M1[i + 1] = machine_new1[0]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; work_T1[i + 1] = time_new1[0]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; answer1[i + 1] = C_finish</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; work_job, work_M, work_T = work_job1, work_M1, work_T1</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; answer = answer1</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; job_init = job_init1</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result.append([gen + 1, min(answer)])&nbsp; # 记录每一次迭代的最优个体</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print('灰狼算法第%.0f次迭代的最优解:%.0f' % (gen + 1, min(answer)))</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best = answer.tolist().index(min(answer))</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; workpiece_number, machine_number, machine_time=np.array([work_job[best]]), np.array([work_M[best]]), np.array([work_T[best]])</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; result=np.array(result).reshape(len(result), 2)[iter,1]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; return workpiece_number, machine_number, machine_time, result</p><p style="margin:0;"># 用于初始读取数据，判断是JSP还是FJSP问题。</p><p style="margin:0;">def load_text(file_name):</p><p style="margin:0;">&nbsp; &nbsp; try:</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; with open(sys.argv[1], "rb") as f:</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f_read = f.read()</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f_cha_info = chardet.detect(f_read)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final_data = f_read.decode(f_cha_info['encoding'])</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return final_data, True</p><p style="margin:0;">&nbsp; &nbsp; except FileNotFoundError:</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; return str(None), False</p><p style="margin:0;"><br /></p><p style="margin:0;"># ORTOOLS运行函数</p><p style="margin:0;">def MinimalJobshopSat(string):</p><p style="margin:0;">&nbsp; &nbsp; a = []</p><p style="margin:0;">&nbsp; &nbsp; for i in string:</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; a.append(int(i))</p><p style="margin:0;">&nbsp; &nbsp; job_num, machine_number = a[0], a[1]</p><p style="margin:0;">&nbsp; &nbsp; for _ in range(3):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; a.pop(0)</p><p style="margin:0;">&nbsp; &nbsp; for i in range(job_num):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; a.pop(3 * job_num * i)</p><p style="margin:0;">&nbsp; &nbsp; all_machines = range(machine_number)</p><p style="margin:0;">&nbsp; &nbsp; jobs_data = []</p><p style="margin:0;">&nbsp; &nbsp; job = []</p><p style="margin:0;">&nbsp; &nbsp; for i, (j, k) in enumerate(zip(a[1::3], a[2::3])):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; job.append((j - 1, k))</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; if (i + 1) % machine_number == 0:</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jobs_data.append(job)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; job = []</p><p style="margin:0;">&nbsp; &nbsp; """Minimal jobshop problem."""</p><p style="margin:0;">&nbsp; &nbsp; # Create the model.</p><p style="margin:0;">&nbsp; &nbsp; model = cp_model.CpModel()</p><p style="margin:0;">&nbsp; &nbsp; # Computes horizon dynamically as the sum of all durations.</p><p style="margin:0;">&nbsp; &nbsp; horizon = sum(task[1] for job in jobs_data for task in job)</p><p style="margin:0;">&nbsp; &nbsp; # Named tuple to store information about created variables.</p><p style="margin:0;">&nbsp; &nbsp; task_type = collections.namedtuple('task_type', 'start end interval')</p><p style="margin:0;">&nbsp; &nbsp; # Named tuple to manipulate solution information.</p><p style="margin:0;">&nbsp; &nbsp; assigned_task_type = collections.namedtuple('assigned_task_type',</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'start job index duration')</p><p style="margin:0;">&nbsp; &nbsp; # Creates job intervals and add to the corresponding machine lists.</p><p style="margin:0;">&nbsp; &nbsp; all_tasks = {}</p><p style="margin:0;">&nbsp; &nbsp; machine_to_intervals = collections.defaultdict(list)</p><p style="margin:0;">&nbsp; &nbsp; for job_id, job in enumerate(jobs_data):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; for task_id, task in enumerate(job):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; machine = task[0]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; duration = task[1]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; suffix = '_%i_%i' % (job_id, task_id)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start_var = model.NewIntVar(0, horizon, 'start' + suffix)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_var = model.NewIntVar(0, horizon, 'end' + suffix)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interval_var = model.NewIntervalVar(start_var, duration, end_var,</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'interval' + suffix)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_tasks[job_id, task_id] = task_type(</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start=start_var, end=end_var, interval=interval_var)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; machine_to_intervals[machine].append(interval_var)</p><p style="margin:0;">&nbsp; &nbsp; # Create and add disjunctive constraints.</p><p style="margin:0;">&nbsp; &nbsp; for machine in all_machines:</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; model.AddNoOverlap(machine_to_intervals[machine])</p><p style="margin:0;">&nbsp; &nbsp; # Precedences inside a job.</p><p style="margin:0;">&nbsp; &nbsp; for job_id, job in enumerate(jobs_data):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; for task_id in range(len(job) - 1):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; model.Add(all_tasks[job_id, task_id +</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1].start &gt;= all_tasks[job_id, task_id].end)</p><p style="margin:0;">&nbsp; &nbsp; # Makespan objective.</p><p style="margin:0;">&nbsp; &nbsp; obj_var = model.NewIntVar(0, horizon, 'makespan')</p><p style="margin:0;">&nbsp; &nbsp; model.AddMaxEquality(obj_var, [</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; all_tasks[job_id, len(job) - 1].end</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; for job_id, job in enumerate(jobs_data)</p><p style="margin:0;">&nbsp; &nbsp; ])</p><p style="margin:0;">&nbsp; &nbsp; model.Minimize(obj_var)</p><p style="margin:0;">&nbsp; &nbsp; # Solve model.</p><p style="margin:0;">&nbsp; &nbsp; solver = cp_model.CpSolver()</p><p style="margin:0;">&nbsp; &nbsp; status = solver.Solve(model)</p><p style="margin:0;">&nbsp; &nbsp; if status == cp_model.OPTIMAL:</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; # Create one list of assigned tasks per machine.</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; assigned_jobs = collections.defaultdict(list)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; for job_id, job in enumerate(jobs_data):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for task_id, task in enumerate(job):</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; machine = task[0]</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assigned_jobs[machine].append(</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assigned_task_type(</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start=solver.Value(all_tasks[job_id, task_id].start),</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; job=job_id,</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index=task_id,</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; duration=task[1]))</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; # Create per machine output lines.</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; print('User time: %.2fs' % solver.UserTime())</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; print('Wall time: %.2fs' % solver.WallTime())</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; print('Optimal Schedule Length: %i' % solver.ObjectiveValue())</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; #进行排产</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; df_result = []</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; for machine in all_machines[::1]:</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; df_result_temp = []</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assigned_jobs[machine].sort()</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for assigned_task in assigned_jobs[machine]:</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; df_result_tuple = (</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assigned_task.job + 1, assigned_task.index + 1,</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assigned_task.start, assigned_task.start + assigned_task.duration</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; df_result_temp.append(df_result_tuple)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; df_result_dic = {f'M{machine + 1}': df_result_temp}</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; df_result.append(df_result_dic)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; #输出到输出文件</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; f = open(sys.argv[2], "w")</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; for line in df_result:</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f.write(str(line) + '\n')</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; f.close()</p><p style="margin:0;"><br /></p><p style="margin:0;"><br /></p><p style="margin:0;">if __name__ == '__main__':</p><p style="margin:0;">&nbsp; &nbsp; time_begin = time.time()</p><p style="margin:0;">&nbsp; &nbsp; file_name = sys.argv[1]&nbsp; #输入文件</p><p style="margin:0;">&nbsp; &nbsp; data_input, check = load_text(file_name)</p><p style="margin:0;">&nbsp; &nbsp; data_inital = list(map(str, data_input.split()))</p><p style="margin:0;">&nbsp; &nbsp; job_num, machine_num = int(data_inital[0]), int(data_inital[1]) #job_num 工件个数 machine_num 机器个数</p><p style="margin:0;">&nbsp; &nbsp; #判断是否为FJSP问题</p><p style="margin:0;">&nbsp; &nbsp; if data_inital[2] == '1':</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; #ortools运行</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; MinimalJobshopSat(data_inital)</p><p style="margin:0;">&nbsp; &nbsp; else:</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; #GWO算法运行</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; p = 0.5&nbsp; # 灰狼算法选择概率</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; iter = 400&nbsp; # 灰狼迭代次数</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; num = 50&nbsp; # 灰狼种群数量</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; #创建灰狼算法类</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; ho = GWO_algorithm(job_num, machine_num, p, iter, num)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; #输出最终工序码，机器码和机器时间，以及最终结果。</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; workpiece_number, machine_number, machine_time, result = ho.gwo_result()</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; #进行排产</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; final_caculate(workpiece_number, machine_number, machine_time, machine_num, job_num)</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; time_end = time.time()</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; all_time = time_end - time_begin</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; #输出结果和时间</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; f = open(sys.argv[2], "a")</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; f.write('最优解：'+str(int(result))+ '\n')</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; f.write('所用时间：'+'{:.0f}分 {:.0f}秒'.format( all_time&nbsp; // 60, all_time&nbsp; % 60)+ '\n')</p><p style="margin:0;">&nbsp; &nbsp; &nbsp; &nbsp; f.close()</p>




